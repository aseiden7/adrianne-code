---
title: "Visualizing ATR OPUS binary files and DPT files in R"
author: "Adrianne Seiden"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: darkly
    highlight: zenburn
    code_folding: hide
knit: (function(inputFile, encoding) {
    rmarkdown::render(inputFile, encoding = encoding,
                     output_dir = "../") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  echo = TRUE,
  results = "markup",
  include = TRUE,
  message = FALSE,
  warning = FALSE
)

# set Box path
box_base <- Sys.getenv("BOX_BASE")
if (box_base == "") stop("BOX_BASE environment variable is not set!")
# set corr_spectra path
corr_spectra <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/ATR_re-processed_251007/ATR-spectrum_re-corrected")
# set dpt_folder path
dpt_folder <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/ATR_re-processed_251007/ATR-spectrum-corr.-DPTs")
# set outputs folder path
outputs_folder <- file.path(box_base, "Salk Institute Project/Salk Data/FTIR_Intact_decomposition_pots/ATR/ATR_OPUS_code_outputs")
```

```{css, echo=FALSE}
/* Custom CSS to make blockquote text same size as normal text */
blockquote {
  font-size: inherit !important;
  line-height: inherit !important;
}
```

# Reading OPUS files
[source](https://spectral-cockpit.github.io/opusreader2/articles/opusreader2_introduction.html)

This code is modified from the original OPUSreader2 documentation [vignettes/opusreader2_introduction.Rmd](https://github.com/spectral-cockpit/opusreader2/blob/main/vignettes/opusreader2_introduction.Rmd) by Philip Baumann and Thomas Knecht. It reads OPUS binary files and extracts metadata and absorbance data, which can then be plotted.

## Plots \& Metadata
The main function, `read_opus()`, reads one or more OPUS files and returns a nested list of class `list_opusreader2`. Each list contains both the spectral data and metadata for each file. The `dsn` argument is the data source name. It can be a character vector of folder paths (to read files recursively) or specific OPUS file paths. Start by testing the read_opus function on your corrected spectra folder, and saving the output of the first file.

```{r setup-first-sample, message=FALSE, warning=FALSE, echo=TRUE}
#load opusreader2 from github.com/spectral-cockpit
library(opusreader2)

#save the data from your corrected files as 'data_test'
data_test <- read_opus(dsn = corr_spectra)
#check the names of the list
names(data_test)
# define 'meas_1' as the first element of the 'data_test' list
meas_1 <- data_test[[1]]
```

### Helper Functions

Function to extract single-channel spectral data from OPUS files and convert it to absorbance.  

ab = -log10(sample/ref)   

I'm a bit unsure about this because I already ran a background correction in the OPUS software... I may try running this with raw data later. The DPT files in "Reading DPT files" section below are unaltered from the OPUS software export.

```{r helper-functions, echo=TRUE, message=FALSE, warning=FALSE}
# Helper function to get spectral data from OPUS file data
getSpectralData <- function(data) {
  # First try to find processed absorbance data
  ab_data <- data$ab
  
  if (!is.null(ab_data) &&
        !is.null(ab_data$wavenumbers) && !is.null(ab_data$data) &&
        is.numeric(ab_data$wavenumbers) && is.numeric(ab_data$data) &&
        length(ab_data$wavenumbers) == length(ab_data$data) &&
        all(is.finite(ab_data$wavenumbers)) && all(is.finite(ab_data$data))) {
    return(list(wavenumbers = ab_data$wavenumbers, data = ab_data$data, type = "processed"))
  }
  
  # Try to calculate absorbance from single-channel data
  sample_data <- data$sc_sample
  ref_data <- data$sc_ref
  
  if (!is.null(sample_data) && !is.null(ref_data) &&
      !is.null(sample_data$wavenumbers) && !is.null(sample_data$data) &&
      !is.null(ref_data$wavenumbers) && !is.null(ref_data$data) &&
      is.numeric(sample_data$wavenumbers) && is.numeric(sample_data$data) &&
      is.numeric(ref_data$wavenumbers) && is.numeric(ref_data$data)) {
    
    # Find common wavenumber range
    sample_wn <- as.vector(sample_data$wavenumbers)
    sample_int <- as.vector(sample_data$data)
    ref_wn <- as.vector(ref_data$wavenumbers)
    ref_int <- as.vector(ref_data$data)
    
    # Find overlapping wavenumber range
    min_wn <- max(min(sample_wn), min(ref_wn))
    max_wn <- min(max(sample_wn), max(ref_wn))
    
    # Filter data to common range
    sample_mask <- sample_wn >= min_wn & sample_wn <= max_wn
    ref_mask <- ref_wn >= min_wn & ref_wn <= max_wn
    
    sample_wn_filtered <- sample_wn[sample_mask]
    sample_int_filtered <- sample_int[sample_mask]
    ref_wn_filtered <- ref_wn[ref_mask]
    ref_int_filtered <- ref_int[ref_mask]
    
    # Interpolate reference to sample wavenumbers if needed
    if (length(sample_wn_filtered) != length(ref_wn_filtered) || 
        !all(abs(sample_wn_filtered - ref_wn_filtered) < 0.1)) {
      ref_int_interp <- approx(ref_wn_filtered, ref_int_filtered, 
                              sample_wn_filtered, rule = 2)$y
    } else {
      ref_int_interp <- ref_int_filtered
    }
    
    # Calculate absorbance: A = -log10(Sample/Reference)
    ratio <- sample_int_filtered / (ref_int_interp + 1e-10)
    absorbance <- -log10(pmax(ratio, 1e-10))
    
    # Remove infinite or NaN values
    valid_idx <- is.finite(absorbance) & is.finite(sample_wn_filtered)
    
    if (sum(valid_idx) > 10) {
      return(list(
        wavenumbers = sample_wn_filtered[valid_idx], 
        data = absorbance[valid_idx], 
        type = "calculated"
      ))
    }
  }
  
  return(NULL)  # No valid spectral data found
}
```

Next I defined a function, plotSpectrum, to plot the spectral data from a single sample (meas_1)

```{r fun-plot-spectrum-and-metadata, echo=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=5}
# data is a list containing OPUS file data, including absorbance and metadata.

plotSpectrum <- function(data) { # nolint: object_name_linter.
  spectral_data <- getSpectralData(data)
  
  if (!is.null(spectral_data)) {
    ylabel <- if (spectral_data$type == "calculated") "Absorbance (calculated)" else "Absorbance"
    title_prefix <- if (spectral_data$type == "calculated") "Calculated absorbance: " else ""
    
    plot(
      spectral_data$wavenumbers, spectral_data$data, type = "l",
      xlab = "Wavenumber (cm⁻¹)", ylab = ylabel,
      main = paste0(title_prefix, data$basic_metadata$dsn_filename),
      xlim = rev(range(spectral_data$wavenumbers))
    )
  } else {
    cat("No valid spectral data found in this file.\n")
    cat("Available data blocks:", paste(names(data), collapse = ", "), "\n")
  }
}
plotSpectrum(meas_1)
```

I then defined the ***metadataTable*** function, to extract and display the a subset of the metadata stored in the data extracted by 'read_opus' in a table format. 

To view all the available data categories, run 'names(meas_1)' in the console. To view the parameters within these categories use str(meas_1$category_name) where 'category_name' is 'basic_metadata', 'optics', etc.
```{r fun-metadata-table, include=FALSE, echo = TRUE, message=FALSE, warning=FALSE}
## Safely extract each value (use NA if missing)
library(knitr)
getval <- function(x) if (!is.null(x) && length(x) > 0) x else NA
metadataTable <- function(data) { # nolint: object_name_linter.
  meta_vec <- c(
    `File Name` = getval(data$basic_metadata$dsn_filename),
    `Timestamp` = getval(data$basic_metadata$timestamp_string),
    `Max Y` = getval(data$ab_data_param$parameters$MXY$parameter_value),
    `Min Y` = getval(data$ab_data_param$parameters$MNY$parameter_value),
    `Aperture Setting` = getval(data$optics$parameters$APT$parameter_value),
    `Scanner Velocity` = getval(data$optics$parameters$VEL$parameter_value),
    `Result Spectrum` = getval(data$acquisition$parameters$PLF$parameter_value),
    `Resolution` = getval(data$acquisition$parameters$RES$parameter_value),
    `Sample Scans` = getval(data$acquisition$parameters$NSS$parameter_value),
    `End Frequency` =
      getval(data$fourier_transformation$parameters$HFQ$parameter_value),
    `Start Frequency` =
      getval(data$fourier_transformation$parameters$LFQ$parameter_value),
    `Duration` = getval(data$instrument$parameters$DUR$parameter_value),
    `Experiment (method)` = getval(data$sample$parameters$EXP$parameter_value)
  )
  meta_long <- data.frame(
    Parameter = names(meta_vec),
    Value = unname(meta_vec),
    row.names = NULL,
    check.names = FALSE
  )

  kable(meta_long, caption = "Metadata", align = "l")
}
metadataTable(meas_1)
```
### Metadata table (folder)
```{r folder-metadata}
for (i in seq_along(data_test)) {
  cat("#### Spectrum", i, ":", names(data_test)[i], "\n\n")
  data_i <- data_test[[i]]
  print(metadataTable(data_i))
}
```

The ***plotMetadata*** function combines the plot and table for a single spectrum.
```{r single-spectrum-metadata, message=FALSE, warning=FALSE, fig.width=8, fig.height=5}
plotMetadata <- function(data) { # nolint: object_name_linter.
  plotSpectrum(data)
  metadataTable(data)
}
plotMetadata(meas_1)
```
### Combined plot and table (folder)
The following for loop runs plotMetadata on each spectrum in the data_test list, which contains all the spectra in the folder. It will plot each spectrum and print its metadata below. Clearly the data varies in quality, with different resolution and sample scans parameters.  

```{r folder-spectrum-metadata, message=FALSE, warning=FALSE, fig.width=8, fig.height=5, results='asis'}
for (i in seq_along(data_test)) {
  cat("#### Spectrum", i, ":", names(data_test)[i], "\n\n")
  data_i <- data_test[[i]]
  
  # Check if we can get valid spectral data
  spectral_data <- getSpectralData(data_i)
  
  if (!is.null(spectral_data)) {
    plotSpectrum(data_i)
    print(metadataTable(data_i))
  } else {
    cat("Data not valid or missing for this spectrum.\n")
    cat("Available data blocks:", paste(names(data_i), collapse = ", "), "\n")
  }
}
```
## Stacking multiple spectra
### Stacking re-runs
This code looks for files with the same sample number and stacks their spectra, to check whether reruns are consistent.
```{r stack-re-runs-new, include= TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=7}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  results = "markup",
  include = TRUE
)
library(opusreader2)
library(RColorBrewer)

data_test <- read_opus(dsn = corr_spectra)

# Helper function to get spectral data from OPUS file data
getSpectralData <- function(data) {
  # First try to find processed absorbance data
  ab_data <- data$ab
  
  if (!is.null(ab_data) &&
        !is.null(ab_data$wavenumbers) && !is.null(ab_data$data) &&
        is.numeric(ab_data$wavenumbers) && is.numeric(ab_data$data) &&
        length(ab_data$wavenumbers) == length(ab_data$data) &&
        all(is.finite(ab_data$wavenumbers)) && all(is.finite(ab_data$data))) {
    return(list(wavenumbers = ab_data$wavenumbers, data = ab_data$data, type = "processed"))
  }
  
  # Try to calculate absorbance from single-channel data
  sample_data <- data$sc_sample
  ref_data <- data$sc_ref
  
  if (!is.null(sample_data) && !is.null(ref_data) &&
      !is.null(sample_data$wavenumbers) && !is.null(sample_data$data) &&
      !is.null(ref_data$wavenumbers) && !is.null(ref_data$data) &&
      is.numeric(sample_data$wavenumbers) && is.numeric(sample_data$data) &&
      is.numeric(ref_data$wavenumbers) && is.numeric(ref_data$data)) {
    
    # Find common wavenumber range
    sample_wn <- as.vector(sample_data$wavenumbers)
    sample_int <- as.vector(sample_data$data)
    ref_wn <- as.vector(ref_data$wavenumbers)
    ref_int <- as.vector(ref_data$data)
    
    # Find overlapping wavenumber range
    min_wn <- max(min(sample_wn), min(ref_wn))
    max_wn <- min(max(sample_wn), max(ref_wn))
    
    # Filter data to common range
    sample_mask <- sample_wn >= min_wn & sample_wn <= max_wn
    ref_mask <- ref_wn >= min_wn & ref_wn <= max_wn
    
    sample_wn_filtered <- sample_wn[sample_mask]
    sample_int_filtered <- sample_int[sample_mask]
    ref_wn_filtered <- ref_wn[ref_mask]
    ref_int_filtered <- ref_int[ref_mask]
    
    # Interpolate reference to sample wavenumbers if needed
    if (length(sample_wn_filtered) != length(ref_wn_filtered) || 
        !all(abs(sample_wn_filtered - ref_wn_filtered) < 0.1)) {
      ref_int_interp <- approx(ref_wn_filtered, ref_int_filtered, 
                              sample_wn_filtered, rule = 2)$y
    } else {
      ref_int_interp <- ref_int_filtered
    }
    
    # Calculate absorbance: A = -log10(Sample/Reference)
    ratio <- sample_int_filtered / (ref_int_interp + 1e-10)
    absorbance <- -log10(pmax(ratio, 1e-10))
    
    # Remove infinite or NaN values
    valid_idx <- is.finite(absorbance) & is.finite(sample_wn_filtered)
    
    if (sum(valid_idx) > 10) {
      return(list(
        wavenumbers = sample_wn_filtered[valid_idx], 
        data = absorbance[valid_idx], 
        type = "calculated"
      ))
    }
  }
  
  return(NULL)  # No valid spectral data found
}

# Helper to extract sample number from filename (e.g., "pot094")
extract_sample_number <- function(filename) {
  m <- regexpr("[a-z]{3}[0-9]+", filename)
  if (m[1] != -1) {
    regmatches(filename, m)
  } else {
    NA
  }
}

# Helper to extract sample type (e.g.,"soil", "root")
extract_sample_type <- function(filename) {
  m <- regexpr("soil|root", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}

# Helper to extract timepoint (e.g., "wk0", "wk40")
extract_timepoint <- function(filename) {
  m <- regexpr("wk[0-9]+", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}

# Group files by sample number, sample type, and timepoint
sample_numbers <- sapply(names(data_test), extract_sample_number)
sample_types <- sapply(names(data_test), extract_sample_type)
timepoints <- sapply(names(data_test), extract_timepoint)

# Create unique combinations of sample number, sample type, and timepoint
sample_combinations <- paste(sample_numbers, sample_types, timepoints, sep = "_")
unique_combinations <- unique(sample_combinations[!is.na(sample_numbers)
                                                  & !is.na(sample_types)
                                                  & !is.na(timepoints)])

# Plot stacked spectra for each unique combination
library(RColorBrewer)
for (combination in unique_combinations) {
  idx <- which(sample_combinations == combination)
  if (length(idx) > 1) {
    # Extract sample number, type, and timepoint from combination
    parts <- strsplit(combination, "_")[[1]]
    sample_num <- parts[1]
    sample_type <- parts[2]
    timepoint <- parts[3]

    spectra <- data_test[idx]
    colors <- brewer.pal(min(length(spectra), 8), "Set1")
    
    # Get spectral data for all spectra in this combination
    spectral_list <- lapply(spectra, getSpectralData)
    valid_spectra <- !sapply(spectral_list, is.null)
    
    if (!any(valid_spectra)) {
      cat("Skipping", combination, "- no valid spectral data\n")
      next
    }
    
    # Filter to valid spectra only
    spectral_list <- spectral_list[valid_spectra]
    spectra <- spectra[valid_spectra]
    colors <- colors[seq_along(spectral_list)]
    
    # Get ranges for plotting
    all_wavenumbers <- unlist(lapply(spectral_list, function(x) x$wavenumbers))
    all_absorbance <- unlist(lapply(spectral_list, function(x) x$data))
    
    plot(NULL, xlim = rev(range(all_wavenumbers, na.rm = TRUE)),
         ylim = range(all_absorbance, na.rm = TRUE),
         xlab = "Wavenumber (cm⁻¹)", ylab = "Absorbance",
         main = paste("Stacked spectra for", sample_num, "-", sample_type, "-", timepoint),
         bty = "l")
    
    for (i in seq_along(spectral_list)) {
      spec_data <- spectral_list[[i]]
      lines(spec_data$wavenumbers, spec_data$data, col = colors[i], lwd = 2)
    }
    
    legend("topright",
           inset = c(-0.05, -0.02),
           legend = names(spectra),
           col = colors[seq_len(length(spectral_list))],
           lwd = 2,
           xpd = TRUE,
           bty = "n")
  }
}
```

### Stacking by crop \& time
This code stacks spectra of the same crop and timepoint.
```{r stack-crop-time, message=FALSE, warning=FALSE, fig.width=10, fig.height=7}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  results = "markup",
  include = TRUE
)
# Helper functions to extract crop and timepoint from filename
extract_crop <- function(filename) {
  m <- regexpr("rice|wheat|soy", filename, ignore.case = TRUE)
  if (m[1] != -1) tolower(regmatches(filename, m)) else NA
}
extract_time <- function(filename) {
  m <- regexpr("wk[0-9]+", filename, ignore.case = TRUE)
  if (m[1] != -1) tolower(regmatches(filename, m)) else NA
}
extract_sample_type <- function(filename) {
  m <- regexpr("root|soil", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}
# Get crop and time for each file
crops <- sapply(names(data_test), extract_crop)
times <- sapply(names(data_test), extract_time)
types <- sapply(names(data_test), extract_sample_type)

# Unique crop-time combinations
combos <- na.omit(unique(paste(crops, times, types, sep = "_")))

library(RColorBrewer)
for (combo in combos) {
  idx <- which(paste(crops, times, types, sep = "_") == combo)
  if (length(idx) > 1) {
    spectra <- data_test[idx]
    colors <- brewer.pal(min(length(spectra), 8), "Set1")
    
    # Get spectral data for all spectra in this combination
    spectral_list <- lapply(spectra, getSpectralData)
    valid_spectra <- !sapply(spectral_list, is.null)
    
    if (!any(valid_spectra)) {
      cat("Skipping", combo, "- no valid spectral data\n")
      next
    }
    
    # Filter to valid spectra only
    spectral_list <- spectral_list[valid_spectra]
    spectra <- spectra[valid_spectra]
    colors <- colors[seq_along(spectral_list)]
    
    # Get ranges for plotting
    all_wavenumbers <- unlist(lapply(spectral_list, function(x) x$wavenumbers))
    all_absorbance <- unlist(lapply(spectral_list, function(x) x$data))
    
    plot(NULL, xlim = rev(range(all_wavenumbers, na.rm = TRUE)),
         ylim = range(all_absorbance, na.rm = TRUE),
         xlab = "Wavenumber (cm⁻¹)", ylab = "Absorbance",
         main = paste("Stacked spectra for", combo),
         bty = "l")
    
    for (i in seq_along(spectral_list)) {
      spec_data <- spectral_list[[i]]
      lines(spec_data$wavenumbers, spec_data$data, col = colors[i], lwd = 2)
    }
    
    legend("topright",
           inset = c(-0.05, -0.02),
           legend = names(spectra),
           col = colors[seq_len(length(spectral_list))],
           lwd = 2,
           xpd = TRUE,
           bty = "n")
  }
}
```

# Reading DPT files
This code is modified from code by Stephany Soledad Chacon, "Box> Salk Institute Project> Salk Data> FTIR_Intact_decomposition_pots> FTIR_analysis.Rmd". Using data in the DPT format, we can extrapolate sample attributes from the file names, then normalize and visualize spectra across replicates, crops, and timepoints. The width of the line bounding the spectra represents the range of the data.
```{r dpt-setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(ggridges)
library(readr)
library(stringr)
library(viridis)
library(dplyr)
library(cowplot)
library(grid)
library(ggsignif)

# set Box path
box_base <- Sys.getenv("BOX_BASE")
if (box_base == "") stop("BOX_BASE environment variable is not set!")
# set dpt_folder path
dpt_folder <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/ATR_re-processed_251007/ATR-spectrum-corr.-DPTs")
```
## Importing FTIR data using readr

### Define file path and import multiple files into one data frame
```{r create-dpt-csv, message=FALSE, warning=FALSE}
# Load required libraries
library(readr)
library(dplyr)
library(tidyr)


# Check if folder exists and list files
if (!dir.exists(dpt_folder)) {
  stop("Directory does not exist: ", dpt_folder)
}

# List and sort files
cat("Files found in directory:\n")
print(list.files(dpt_folder))
DPTfiles <- sort(# nolint: object_name_linter.
                 list.files(dpt_folder, pattern = ".dpt"))

cat("Number of .dpt files:", length(DPTfiles), "\n")

# Read files individually and combine
dpt_data_list <- list()

for (i in seq_along(DPTfiles)) {
  file_path <- file.path(dpt_folder, DPTfiles[i])

  # Read individual file
  temp_data <- readr::read_delim(file_path,
                                 delim = " ",
                                 col_names = c("wavenumber", "absorbance"),
                                 show_col_types = FALSE,
                                 skip_empty_rows = TRUE,
                                 skip = 0)

  # Add filename column
  temp_data$filename <- DPTfiles[i]

  # Store in list
  dpt_data_list[[i]] <- temp_data
}

# Combine all data
dpt_data <- bind_rows(dpt_data_list)

# Convert absorbance to numeric (handle any parsing issues)
dpt_data$absorbance <- as.numeric(dpt_data$absorbance)

# Remove any rows with NA values that might have been created during parsing
dpt_data <- dpt_data[complete.cases(dpt_data), ]

# filter out KBr
dpt_data <- dpt_data[!grepl("KBr", dpt_data$filename), ]

# #filter out anomalous spectra
# anomalous_spectra <- c("DRIFTS_pot103_13Crice_wk0_root_recNMR_250725.0.dpt",
#                        "DRIFTS_pot103_13Crice_wk0_root_vial1_250725.0.dpt",
#                        "DRIFTS_pot079_13Crice_wk0_root_250725.0.dpt")

# dpt_data <- dpt_data[!dpt_data$filename %in% anomalous_spectra, ]

# Create wide format table
dfw <- dpt_data %>%
  pivot_wider(names_from = filename,
              values_from = absorbance)

# Save to CSV with today's date
today <- Sys.Date()
csvName <- paste0(outputs_folder, "/ATR_wide_", today, ".csv") # nolint: object_name_linter.
write_csv(dfw, csvName)
```

### Extract sample info from filename
Using the long format dataframe `dpt_data`
**format example: pot028_13C_wheat_wk0_soil_241209.0.dpt**
```{r extract-sample-info, message=FALSE, warning=FALSE}
# First, let's check what our data looks like
cat("Column filenames:", colnames(dpt_data), "\n")

# Extract pot/jar identifier
dpt_data$source <- sapply(strsplit(dpt_data$filename, "_"), function(x) {
  pot_part <- x[1]
  # Extract just "pot" or "jar" part
  if (grepl("pot", pot_part)) {
    "pot"
  } else if (grepl("jar", pot_part)) {
    "jar"
  } else {
    "unknown"
  }
})
unique(dpt_data$source)

# Extract ID number
dpt_data$ID <- sapply(strsplit(dpt_data$filename, "_"), function(x) {
  pot_part <- x[1]
  # Extract numbers from pot/jar identifier
  number <- gsub("(pot|jar)", "", pot_part)
  number
})
unique(dpt_data$ID)

# Extract isotope information (13C or 12C)
dpt_data$isotope <- sapply(strsplit(dpt_data$filename, "_"), function(x) {
  # Look for the part with isotope info (usually position 2)
  isotope_part <- x[2]
  if (grepl("13C", isotope_part)) {
    13
  } else if (grepl("12C", isotope_part)) {
    12
  } else {
    "unknown"
  }
})
unique(dpt_data$isotope)

# Extract crop type 3rd position
dpt_data$crop <- sapply(strsplit(dpt_data$filename, "_"), function(x) {
  crop <- x[3]
  crop
})
unique(dpt_data$crop)

# Extract timepoint
dpt_data$timepoint <- sapply(strsplit(dpt_data$filename, "_"), `[`, 4)
unique(dpt_data$timepoint)

# Extract sample type (root, soil, etc.) - usually position 5
dpt_data$type <- sapply(strsplit(dpt_data$filename, "_"), `[`, 5)
unique(dpt_data$type)

# Extract run date
# find last segment
dpt_data$run_date <- sapply(dpt_data$filename, function(x) {
  segments <- strsplit(x, "_")[[1]]
  last_segment <- segments[length(segments)]
  date <- gsub("\\..*$", "", last_segment) # Remove .dpt extension
})
unique(dpt_data$run_date)

# Extract notes
dpt_data$notes <- sapply(dpt_data$filename, function(x) {
  # Look for the part with notes (usually position 6)
  segments <- strsplit(x, "_")[[1]]
  if (length(segments) > 6) {
    notes_part <- segments[6]
  } else {
    notes_part <- NA
  }
})
unique(dpt_data$notes)
head(dpt_data)

# Create wide format table
dfw2 <- dpt_data %>%
  pivot_wider(names_from = filename,
              values_from = absorbance)

# Save to CSV with today's date
today <- Sys.Date()
csvName2 <- paste0(outputs_folder, "/ATR_wide_info_", today, ".csv")
write_csv(dfw2, csvName2)
```
### Normalize absorbance data
For each file, create a normalized absorbance column (nabs) by dividing each absorbance value by the maximum absorbance for that file.
```{r plots, message=FALSE, warning=FALSE}
library(tidyverse)
library(gridExtra)
library(cowplot)
library(grid)
library(ggsignif)
library(viridis)
library(ggridges)
library(knitr)
library(gridExtra)

roots <- dpt_data %>% filter(type == "root")
soil <- dpt_data %>% filter(type == "soil")
palc1 <- c("noPlant" = "#7B41A9", "rice" = "#FC9D33",
           "wheat" = "#98C65D", "soy" = "#FE318E")

# Normalize absorbance values
rootsn <- roots %>%
  group_by(filename) %>%
  mutate(nabs = absorbance / max(absorbance))

soiln <- soil %>%
  group_by(filename) %>%
  mutate(nabs = absorbance / max(absorbance))
```

## Plotting by timepoint and type
These plots are of normalized absorbance values. The thickness of the opaque line represents the range of the data. Dotted lines at specific wavenumbers indicate key absorption features of suberin. Lines in black are exclusively assigned to suberin, while gray lines are non-exclusively assigned.  

According to Martins et al. 2014:  

> Major peaks, which can be almost exclusively assigned to suberin, are at 2921 cm^-1^, 2851 cm^-1^ and 1737 cm^-1^. The remaining peaks are simultaneously assigned to the fungal cell wall and either to suberin (1158 cm^-1^ and 1635 cm^-1^)...
> 
> --- Martins, I., Hartmann, D.O., Alves, P.C. et al. Elucidating how the saprophytic fungus Aspergillus nidulans uses the plant polyester suberin as carbon source. BMC Genomics 15, 613 (2014). https://doi.org/10.1186/1471-2164-15-613

1737 = C=O stretch (esters) 

### Week 0
```{r plotting wk0, message=FALSE, warning=FALSE, comment=FALSE, fig.width=9, fig.height=6}
palc1 <- c("noPlant" = "#7B41A9", "rice" = "#FC9D33",
           "wheat" = "#98C65D", "soy" = "#FE318E")
#roots week 0
root0 <- rootsn %>%
  filter(timepoint == "wk0") %>%
  filter(ID != "047") %>% # 47 has a weird peak at the start
  mutate(crop = factor(crop, levels = c("noPlant", "wheat", "rice", "soy")))
#Plot
root0_plot <- root0 %>%
  ggplot(mapping = aes(x = wavenumber,
                       y = crop,
                       height = nabs,
                       group = crop,
                       fill = crop,
                       color = crop)) +
  geom_density_ridges(stat = "identity",
                      scale = 3,
                      alpha = 0.25) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  xlim(4000, 400) +
  theme_classic() +
  scale_fill_manual(values = palc1) +
  scale_color_manual(values = palc1) +
  ggtitle("Roots at week 0")
root0_plot
unique(root0$ID)
ggsave(file.path(outputs_folder, "Root_week0_ATR.png"), root0_plot)


# Soils week 0
soil0 <- soiln %>% # nolint: commented_code_linter.
  filter(timepoint == "wk0") # nolint
soil0

 palc1 <- c("noPlant" = "#7B41A9", "rice" = "#FC9D33",
           "wheat" = "#98C65D", "soy" = "#FE318E")

soil0_plot <- soil0 %>% # nolint: commented_code_linter.
  ggplot(mapping = aes(x = wavenumber,
                       y = crop, # nolint: commented_code_linter.
                       height = nabs, # nolint: commented_code_linter.
                       group = crop, # nolint: commented_code_linter.
                       fill = crop, # nolint: commented_code_linter.
                       color = crop)) +
  geom_density_ridges(stat = "identity",
                      scale = 3, # nolint: commented_code_linter.
                      alpha = 0.25) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  xlim(4000, 400) +
  theme_classic() +
  scale_fill_manual(values = palc1) +
  scale_color_manual(values = palc1) +
  ggtitle("Soils at week 0") # nolint: commented_code_linter.
soil0_plot
unique(soil0$ID) # nolint: commented_code_linter.
ggsave(file.path(outputs_folder, "Soil_week0_ATR.png"), soil0_plot)
```

### Week 10
```{r plotting wk10, message=FALSE, warning=FALSE, fig.width=9, fig.height=6}
palc1 <- c("noPlant" = "#7B41A9", "rice" = "#FC9D33",
           "wheat" = "#98C65D", "soy" = "#FE318E")
#roots week 10
root10 <- rootsn %>%
  filter(timepoint == "wk10") %>%
  filter(ID != "094") %>% # 94 has a huge ~3500 peak compared to other wk10 soy
  mutate(crop = factor(crop, levels = c("noPlant", "wheat", "rice", "soy")))
#Plot
#Plot
root10_plot <- root10 %>%
  ggplot(mapping = aes(x = wavenumber,
                       y = crop,
                       height = nabs,
                       group = crop,
                       fill = crop,
                       color = crop)) +
  geom_density_ridges(stat = "identity",
                      scale = 3,
                      alpha = 0.25) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  xlim(4000, 400) +
  theme_classic() +
  scale_fill_manual(values = palc1) +
  scale_color_manual(values = palc1) +
  ggtitle("Roots at week 10")
root10_plot
unique(root10$ID)
ggsave(file.path(outputs_folder, "Root_week10_ATR.png"), root10_plot)

# Soils week 10
soil10 <- soiln %>%
  filter(timepoint == "wk10") %>%
  mutate(crop = factor(crop, levels = c("noPlant", "wheat", "rice", "soy")))

palc1 <- c("noPlant" = "#7B41A9", "rice" = "#FC9D33",
           "wheat" = "#98C65D", "soy" = "#FE318E")

soil10_plot <- soil10 %>%
  ggplot(mapping = aes(x = wavenumber,
                       y = crop,
                       height = nabs,
                       group = crop,
                       fill = crop,
                       color = crop)) +
  geom_density_ridges(stat = "identity",
                      scale = 3,
                      alpha = 0.25) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5) +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5) +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5) +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  xlim(4000, 400) +
  theme_classic() +
  scale_fill_manual(values = palc1) +
  scale_color_manual(values = palc1) +
  ggtitle("Soils at week 10")
soil10_plot
unique(soil10$ID)
ggsave(file.path(outputs_folder, "Soil_week10_ATR.png"), soil10_plot)
```
## Plotting by crop
These plots are of normalized absorbance values. The thickness of the opaque line represents the range of the data. Dotted lines at specific wavenumbers indicate key absorption features of suberin. Lines in black are exclusively assigned to suberin, while gray lines are non-exclusively assigned.  

According to Martins et al. 2014:  

> Major peaks, which can be almost exclusively assigned to suberin, are at 2921 cm^-1^, 2851 cm^-1^ and 1737 cm^-1^. The remaining peaks are simultaneously assigned to the fungal cell wall and either to suberin (1158 cm^-1^ and 1635 cm^-1^)...
> 
> --- Martins, I., Hartmann, D.O., Alves, P.C. et al. Elucidating how the saprophytic fungus Aspergillus nidulans uses the plant polyester suberin as carbon source. BMC Genomics 15, 613 (2014). https://doi.org/10.1186/1471-2164-15-613

1737 = C=O stretch (esters) 

### Wheat Roots
```{r plotting wheat, message=FALSE, warning=FALSE, fig.width=9, fig.height=6}
palc2 <- c("wk0" = "#B4D586", "wk10" = "#98C559","wk20" = "#79A63A",
           "wk30" = "#58792A", "wk40" = "#374B1B")
wheat <- rootsn %>%
  group_by(timepoint) %>%
  filter(crop == "wheat")

wheat$absorbance <- as.numeric(wheat$absorbance)

wheat_plot <- ggplot(wheat,
                     aes(x = wavenumber,
                         y = absorbance,
                         color = timepoint)) +
  xlim(4000, 1000) +
  geom_line() +
  theme_classic() +
  scale_color_manual(values = palc2) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  ggtitle("Wheat Roots ATR")
wheat_plot
unique(wheat$ID)
```
### rice roots
```{r plotting rice, message=FALSE, warning=FALSE, fig.width=9, fig.height=6}
palc3 <- c("wk0" = "#FDB35E", "wk10" = "#FC9D33","wk29" = "#F18204",
           "wk40" = "#B56203")

rice <- rootsn %>%
  group_by(timepoint) %>%
  filter(crop == "rice")

rice$absorbance <- as.numeric(rice$absorbance)

rice_plot <- ggplot(rice,
                    aes(x = wavenumber,
                        y = absorbance,
                        color = timepoint)) +
  xlim(4000, 1000) +
  ylim(0, 1.5) +
  geom_line() +
  theme_classic() +
  scale_color_manual(values = palc3) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  ggtitle("Rice Roots ATR")
rice_plot
unique(rice$ID)
```
### soy roots
```{r plotting soy, echo=FALSE, message=FALSE, warning=FALSE, fig.width=9, fig.height=6}
palc4 <- c("wk0" = "#FE71B1", "wk10" = "#FE318E","wk20" = "#F4016E",
           "wk30" = "#B70153", "wk40" = "#7A0137")
soy <- rootsn %>%
  group_by(timepoint) %>%
  filter(crop == "soy") 

soy$absorbance <- as.numeric(soy$absorbance)

soy_plot <- ggplot(soy,
                   aes(x = wavenumber,
                       y = absorbance,
                       color = timepoint)) +
  xlim(4000, 1000) +
  geom_line() +
  theme_classic() +
  scale_color_manual(values = palc4) +
  geom_vline(xintercept = 2921, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 2851, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1737, linetype = "dotted", linewidth = 0.5, color = "black") +
  geom_vline(xintercept = 1158, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  geom_vline(xintercept = 1635, linetype = "dotted", linewidth = 0.5, color = "darkgray") +
  ggtitle("Soy Roots ATR")
soy_plot
unique(soy$ID)
```