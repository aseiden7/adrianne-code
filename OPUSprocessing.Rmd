---
title: "Visualizing OPUS binary files and DPT files in R"
author: "Adrianne Seiden"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: darkly
    highlight: zenburn
    code_folding: hide
knit: (function(inputFile, encoding) {
    rmarkdown::render(inputFile, encoding = encoding,
                     output_dir = "../adrianne-code/") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  echo = TRUE,
  results = "markup",
  include = TRUE,
  message = FALSE,
  warning = FALSE
)

# set Box path
box_base <- Sys.getenv("BOX_BASE")
if (box_base == "") stop("BOX_BASE environment variable is not set!")
# set corr_spectra path
corr_spectra <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/Corrected_files")
# set dpt_folder path
dpt_folder <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/DPT_files")
# set outputs folder path
outputs_folder <- file.path(box_base, "Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/OPUS_code_outputs")
```

# Reading OPUS files
[source](https://spectral-cockpit.github.io/opusreader2/articles/opusreader2_introduction.html)

This code is modified from the original OPUSreader2 documentation [vignettes/opusreader2_introduction.Rmd](https://github.com/spectral-cockpit/opusreader2/blob/main/vignettes/opusreader2_introduction.Rmd) by Philip Baumann and Thomas Knecht. It reads OPUS binary files and extracts metadata and absorbance data, which can then be plotted.

## Plots \& Metadata
The main function, `read_opus()`, reads one or more OPUS files and returns a nested list of class `list_opusreader2`. Each list contains both the spectral data and metadata for each file. The `dsn` argument is the data source name. It can be a character vector of folder paths (to read files recursively) or specific OPUS file paths. Start by testing the read_opus function on your corrected spectra folder, and saving the output of the first file.

```{r setup-first-sample, message=FALSE, warning=FALSE, echo=TRUE}
#load opusreader2 from github.com/spectral-cockpit
library(opusreader2)

#save the path to your corrected spectra
# # Mac path
# corr_spectra <- "/Users/adrianneseiden/Library/CloudStorage/Box-Box/Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/Corrected_files" # nolint
#  # Windows path
# corr_spectra <- "C:/Users/adria/Box/Box-Box/Salk Institute Project/AKS Salk files/Adrianne_FTIRdata/Corrected_files" # nolint
# # Relative path
# corr_spectra <- "../Adrianne_FTIRdata/Corrected_files"

#save the data from your corrected files as 'data_test'
data_test <- read_opus(dsn = corr_spectra)
#check the names of the list
names(data_test)
# define 'meas_1' as the first element of the 'data_test' list
meas_1 <- data_test[[1]]
```

Next I defined a function, plotSpectrum, to plot the spectral data from a single sample (meas_1)

```{r fun-plot-spectrum-and-metadata, echo=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=5}
# data is a list containing OPUS file data, including absorbance and metadata.

plotSpectrum <- function(data) { # nolint: object_name_linter.
  ab_data <- data$ab
  if (!is.null(ab_data) &&
        !is.null(ab_data$wavenumbers) && !is.null(ab_data$data) &&
        is.numeric(ab_data$wavenumbers) && is.numeric(ab_data$data) &&
        length(ab_data$wavenumbers) == length(ab_data$data) &&
        all(is.finite(ab_data$wavenumbers)) && all(is.finite(ab_data$data))) {
    plot(
      ab_data$wavenumbers, ab_data$data, type = "l",
      xlab = "Wavenumber (cm⁻¹)", ylab = "Absorbance",
      main = data$basic_metadata$dsn_filename,
      xlim = rev(range(ab_data$wavenumbers))
    )
  } else {
    cat("Absorbance data not found or not valid in this file.\n")
    str(ab_data)
  }
}
plotSpectrum(meas_1)
```

I then defined the ***metadataTable*** function, to extract and display the a subset of the metadata stored in the data extracted by 'read_opus' in a table format. 

To view all the available data categories, run 'names(meas_1)' in the console. To view the parameters within these categories use str(meas_1$category_name) where 'category_name' is 'basic_metadata', 'optics', etc.
```{r fun-metadata-table, include=FALSE, echo = TRUE, message=FALSE, warning=FALSE}
## Safely extract each value (use NA if missing)
library(knitr)
getval <- function(x) if (!is.null(x) && length(x) > 0) x else NA
metadataTable <- function(data) { # nolint: object_name_linter.
  meta_vec <- c(
    `File Name` = getval(data$basic_metadata$dsn_filename),
    `Timestamp` = getval(data$basic_metadata$timestamp_string),
    `Max Y` = getval(data$ab_data_param$parameters$MXY$parameter_value),
    `Min Y` = getval(data$ab_data_param$parameters$MNY$parameter_value),
    `Aperture Setting` = getval(data$optics$parameters$APT$parameter_value),
    `Scanner Velocity` = getval(data$optics$parameters$VEL$parameter_value),
    `Result Spectrum` = getval(data$acquisition$parameters$PLF$parameter_value),
    `Resolution` = getval(data$acquisition$parameters$RES$parameter_value),
    `Sample Scans` = getval(data$acquisition$parameters$NSS$parameter_value),
    `End Frequency` =
      getval(data$fourier_transformation$parameters$HFQ$parameter_value),
    `Start Frequency` =
      getval(data$fourier_transformation$parameters$LFQ$parameter_value),
    `Duration` = getval(data$instrument$parameters$DUR$parameter_value),
    `Experiment (method)` = getval(data$sample$parameters$EXP$parameter_value)
  )
  meta_long <- data.frame(
    Parameter = names(meta_vec),
    Value = unname(meta_vec),
    row.names = NULL,
    check.names = FALSE
  )

  kable(meta_long, caption = "Metadata", align = "l")
}
metadataTable(meas_1)
```

The ***plotMetadata*** function combines the plot and table for a single spectrum.
```{r single-spectrum-metadata, message=FALSE, warning=FALSE, fig.width=8, fig.height=5}
plotMetadata <- function(data) { # nolint: object_name_linter.
  plotSpectrum(data)
  metadataTable(data)
}
plotMetadata(meas_1)
```
### Combined plot and table (folder)
The following for loop runs plotMetadata on each spectrum in the data_test list, which contains all the spectra in the folder. It will plot each spectrum and print its metadata below.
```{r folder-spectrum-metadata, message=FALSE, warning=FALSE, fig.width=8, fig.height=5, results='asis'}
for (i in seq_along(data_test)) {
  cat("#### Spectrum", i, ":", names(data_test)[i], "\n\n")
  data_i <- data_test[[i]]
  ab_data <- data_i$ab
  valid <- !is.null(ab_data) &&
    !is.null(ab_data$wavenumbers) && !is.null(ab_data$data) &&
    is.numeric(ab_data$wavenumbers) && is.numeric(ab_data$data) &&
    length(ab_data$wavenumbers) == length(ab_data$data) &&
    all(is.finite(ab_data$wavenumbers)) && all(is.finite(ab_data$data))
  if (valid) {
    plotSpectrum(data_i)
    print(metadataTable(data_i))
  } else {
    cat("Data not valid or missing for this spectrum.\n")
    str(ab_data)
  }
}
```
## Stacking multiple spectra
### Stacking re-runs
This code looks for files with the same sample number and stacks their spectra, to check whether reruns are consistent.
```{r stack-re-runs-new, include= TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=7}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  results = "markup",
  include = TRUE
)
library(opusreader2)
library(RColorBrewer)



data_test <- read_opus(dsn = corr_spectra)

# Helper to extract sample number from filename (e.g., "pot094")
extract_sample_number <- function(filename) {
  m <- regexpr("[a-z]{3}[0-9]+", filename)
  if (m[1] != -1) {
    regmatches(filename, m)
  } else {
    NA
  }
}

# Helper to extract sample type (e.g.,"soil", "root")
extract_sample_type <- function(filename) {
  m <- regexpr("soil|root", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}

# Helper to extract timepoint (e.g., "wk0", "wk40")
extract_timepoint <- function(filename) {
  m <- regexpr("wk[0-9]+", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}

# Group files by sample number, sample type, and timepoint
sample_numbers <- sapply(names(data_test), extract_sample_number)
sample_types <- sapply(names(data_test), extract_sample_type)
timepoints <- sapply(names(data_test), extract_timepoint)

# Create unique combinations of sample number, sample type, and timepoint
sample_combinations <- paste(sample_numbers, sample_types, timepoints, sep = "_")
unique_combinations <- unique(sample_combinations[!is.na(sample_numbers)
                                                  & !is.na(sample_types)
                                                  & !is.na(timepoints)])

# Plot stacked spectra for each unique combination
library(RColorBrewer)
for (combination in unique_combinations) {
  idx <- which(sample_combinations == combination)
  if (length(idx) > 1) {
    # Extract sample number, type, and timepoint from combination
    parts <- strsplit(combination, "_")[[1]]
    sample_num <- parts[1]
    sample_type <- parts[2]
    timepoint <- parts[3]

    spectra <- data_test[idx]
    colors <- brewer.pal(min(length(spectra), 8), "Set1")
    plot(NULL, xlim = rev(range(spectra[[1]]$ab$wavenumbers)),
         ylim = range(sapply(spectra, function(x) x$ab$data), na.rm = TRUE),
         xlab = "Wavenumber (cm⁻¹)", ylab = "Absorbance",
         main = paste("Stacked spectra for", sample_num, "-", sample_type, "-", timepoint),
         bty = "l")
    for (i in seq_along(spectra)) {
      ab_data <- spectra[[i]]$ab
      if (!is.null(ab_data) && !is.null(ab_data$wavenumbers) &&
            !is.null(ab_data$data)) {
        lines(ab_data$wavenumbers, ab_data$data, col = colors[i], lwd = 2)
      }
    }
    legend("topright",
           inset = c(-0.05, -0.02),
           legend = names(spectra),
           col = colors[seq_along(spectra)],
           lwd = 2,
           xpd = TRUE,
           bty = "n")
  }
}
```

### Stacking by crop \& time
This code stacks spectra of the same crop and timepoint.
```{r stack-crop-time, message=FALSE, warning=FALSE, fig.width=10, fig.height=7}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  results = "markup",
  include = TRUE
)
# Helper functions to extract crop and timepoint from filename
extract_crop <- function(filename) {
  m <- regexpr("rice|wheat|soy", filename, ignore.case = TRUE)
  if (m[1] != -1) tolower(regmatches(filename, m)) else NA
}
extract_time <- function(filename) {
  m <- regexpr("wk[0-9]+", filename, ignore.case = TRUE)
  if (m[1] != -1) tolower(regmatches(filename, m)) else NA
}
extract_sample_type <- function(filename) {
  m <- regexpr("root|soil", filename, ignore.case = TRUE)
  if (m[1] != -1) {
    tolower(regmatches(filename, m))
  } else {
    NA
  }
}
# Get crop and time for each file
crops <- sapply(names(data_test), extract_crop)
times <- sapply(names(data_test), extract_time)
types <- sapply(names(data_test), extract_sample_type)

# Unique crop-time combinations
combos <- na.omit(unique(paste(crops, times, types, sep = "_")))

library(RColorBrewer)
for (combo in combos) {
  idx <- which(paste(crops, times, types, sep = "_") == combo)
  if (length(idx) > 1) {
    spectra <- data_test[idx]
    colors <- brewer.pal(min(length(spectra), 8), "Set1")
    plot(NULL, xlim = rev(range(spectra[[1]]$ab$wavenumbers)),
         ylim = range(sapply(spectra, function(x) x$ab$data), na.rm = TRUE),
         xlab = "Wavenumber (cm⁻¹)", ylab = "Absorbance",
         main = paste("Stacked spectra for", combo),
         bty = "l")
    for (i in seq_along(spectra)) {
      ab_data <- spectra[[i]]$ab
      if (!is.null(ab_data) &&
            !is.null(ab_data$wavenumbers)
          && !is.null(ab_data$data)) {
        lines(ab_data$wavenumbers, ab_data$data, col = colors[i], lwd = 2)
      }
    }
    legend("topright",
           inset = c(-0.05, -0.02),
           legend = names(spectra),
           col = colors[seq_along(spectra)],
           lwd = 2,
           xpd = TRUE,
           bty = "n")
  }
}
```